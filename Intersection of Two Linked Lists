
Brute force: 


Here’s the idea: Use two pointers, one starting at the head of `listA` and the other at the head of `listB`. When a pointer reaches the end of its respective list, instead of stopping, it jumps to the head of the other list. This "switching" ensures that both pointers traverse the same total distance, even if the lists have different lengths. 

Now, think about this—if the lists intersect, the pointers will eventually meet at the intersection node. If they don’t intersect, the pointers will both reach `null` at the same time. 

var getIntersectionNode = function(headA, headB) {
    let PointerA=headA;
    let PointerB=headB;
    if(!headA || !headB) return null;
    while(PointerA!==PointerB){
        PointerA=PointerA?PointerA.next:headB;
        PointerB=PointerB?PointerB.next:headA;
    }
    return PointerA;
    
};

Brute Force2: 
Yes, that would indeed work as a brute force approach! What you'd do is take each node from `listA` one by one, and compare it with every node in `listB`. If you find a match (i.e., the two nodes are the same object in memory), you've found the intersection. If no match is found after comparing all nodes, return `null`. 

However, this brute force approach is highly inefficient. The time complexity would be **O(m × n)**, where `m` and `n` are the lengths of `listA` and `listB` respectively. This is because for every node in `listA`, you're iterating through the entirety of `listB`.

var getIntersectionNode = function(headA, headB) {
    let currA=headA;
    while(currA){
        let currB=headB;
        while(currB){
            if(currA==currB){
                return currA;
            }
            currB=currB.next;
        }
        currA=currA.next;
    }

    return null;
    
};


optimized Approch : 
Ah, you're thinking about the **hash set approach**, which is a valid and straightforward way to solve the problem! Let me explain it step by step:

### Hash Set Approach:
The idea is to use a **hash set** to store all the nodes from `headB`. Once we have the set, we can iterate through `headA` and check if any node in `headA` exists in the set. If we find a match, that's the intersection node! If no match is found after traversing `headA`, then there is no intersection.

### How It Works:
1. **Step 1**: Create an empty hash set.
2. **Step 2**: Traverse through `headB` and add each node to the hash set. This ensures that every node in `headB` is stored in the set for quick lookup.
3. **Step 3**: Traverse through `headA` and check for each node if it exists in the hash set. If a node from `headA` exists in the set, you've found the intersection node!
4. **Step 4**: If you finish traversing `headA` without finding any node in the set, return `null` because there's no intersection.


### Time and Space Complexity:
- **Time Complexity**: O(m + n), where `m` is the length of `headA` and `n` is the length of `headB`.
- Traversing `headB` takes O(n).
- Traversing `headA` takes O(m).
- **Space Complexity**: O(n), because we store all nodes from `headB` in the hash set.

code:

var getIntersectionNode = function(headA, headB) {
    let set= new Set();
    while(headB){
        set.add(headB)
        headB=headB.next;
    }
    while(headA){
        if(set.has(headA)){
            return headA;
        }
        headA=headA.next;
    }

    return null;


  
};
