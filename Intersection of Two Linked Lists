
Brute force: 


Here’s the idea: Use two pointers, one starting at the head of `listA` and the other at the head of `listB`. When a pointer reaches the end of its respective list, instead of stopping, it jumps to the head of the other list. This "switching" ensures that both pointers traverse the same total distance, even if the lists have different lengths. 

Now, think about this—if the lists intersect, the pointers will eventually meet at the intersection node. If they don’t intersect, the pointers will both reach `null` at the same time. 

var getIntersectionNode = function(headA, headB) {
    let PointerA=headA;
    let PointerB=headB;
    if(!headA || !headB) return null;
    while(PointerA!==PointerB){
        PointerA=PointerA?PointerA.next:headB;
        PointerB=PointerB?PointerB.next:headA;
    }
    return PointerA;
    
};

Brute Force2: 
Yes, that would indeed work as a brute force approach! What you'd do is take each node from `listA` one by one, and compare it with every node in `listB`. If you find a match (i.e., the two nodes are the same object in memory), you've found the intersection. If no match is found after comparing all nodes, return `null`. 

However, this brute force approach is highly inefficient. The time complexity would be **O(m × n)**, where `m` and `n` are the lengths of `listA` and `listB` respectively. This is because for every node in `listA`, you're iterating through the entirety of `listB`.

var getIntersectionNode = function(headA, headB) {
    let currA=headA;
    while(currA){
        let currB=headB;
        while(currB){
            if(currA==currB){
                return currA;
            }
            currB=currB.next;
        }
        currA=currA.next;
    }

    return null;
    
};
